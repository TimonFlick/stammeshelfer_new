-- Custom types
create type public.app_permission as enum ('todos.delete', 'todos.create', 'todos.update', 'todos.read', 'users.delete', 'users.create', 'users.update', 'users.read');
create type public.app_role as enum ('admin', 'stammesfuehrung', 'stammesmitglied');
-- USER ROLES
create table public.user_roles (
  id        bigint generated by default as identity primary key,
  user_id   uuid references auth.users on delete cascade not null,
  role      app_role not null,
  unique (user_id, role)
);
comment on table public.user_roles is 'Application roles for each user.';
-- ROLE PERMISSIONS
create table public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         app_role not null,
  permission   app_permission not null,
  unique (role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role.';

insert into public.role_permissions (role, permission)
values
  ('admin', 'todos.delete'),
  ('admin', 'todos.create'),
  ('admin', 'todos.update'),
  ('admin', 'todos.read'),
  ('admin', 'users.delete'),
  ('admin', 'users.create'),
  ('admin', 'users.update'),
  ('admin', 'users.read'),
  ('stammesfuehrung', 'todos.delete'),
  ('stammesfuehrung', 'todos.create'),
  ('stammesfuehrung', 'todos.update'),
  ('stammesfuehrung', 'todos.read');
  
alter table public.user_roles enable row level security;
alter table public.role_permissions enable row level security;


-- RLS Policies for role_permissions (readable by authenticated users)
create policy "Role permissions are viewable by authenticated users"
  on public.role_permissions for select
  to authenticated
  using (true);

-- RLS Policies for user_roles (users can view their own roles)
create policy "Users can view their own roles"
  on public.user_roles for select
  to authenticated
  using (auth.uid() = user_id);

  -- Function to assign default role on user signup
create or replace function public.assign_default_role()
returns trigger as $$
begin
  insert into public.user_roles (user_id, role)
  values (new.id, 'stammesmitglied'::public.app_role)
  on conflict (user_id, role) do nothing;
  return new;
end;
$$ language plpgsql security definer;

-- Trigger to assign default role when user signs up
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute function public.assign_default_role();


create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
stable
security definer
set search_path = public
as $$
  declare
    claims jsonb;
    user_roles_array text[];
    user_permissions_array text[];
    user_id_val uuid;
  begin
    -- Extract user_id safely
    user_id_val := (event->>'user_id')::uuid;
    
    if user_id_val is null then
      return event;
    end if;

    -- Fetch ALL user roles as an array
    select array_agg(role::text) into user_roles_array
    from public.user_roles
    where user_id = user_id_val;

    -- Fetch ALL permissions for user's roles from role_permissions table
    select array_agg(distinct rp.permission::text) into user_permissions_array
    from public.role_permissions rp
    where rp.role = any(
      select role from public.user_roles where user_id = user_id_val
    );

    claims := event->'claims';

    if user_roles_array is not null and array_length(user_roles_array, 1) > 0 then
      -- Set the roles claim as an array
      claims := jsonb_set(claims, '{user_roles}', to_jsonb(user_roles_array));
    else
      -- Default to empty array if no roles
      claims := jsonb_set(claims, '{user_roles}', '[]'::jsonb);
    end if;

    if user_permissions_array is not null and array_length(user_permissions_array, 1) > 0 then
      -- Set the permissions claim as an array
      claims := jsonb_set(claims, '{user_permissions}', to_jsonb(user_permissions_array));
    else
      -- Default to empty array if no permissions
      claims := jsonb_set(claims, '{user_permissions}', '[]'::jsonb);
    end if;

    -- Update the 'claims' object in the original event
    event := jsonb_set(event, '{claims}', claims);

    return event;
  end;
$$;

grant usage on schema public to supabase_auth_admin;
grant execute
  on function public.custom_access_token_hook
  to supabase_auth_admin;
revoke execute
  on function public.custom_access_token_hook
  from authenticated, anon, public;
grant all
  on table public.user_roles
to supabase_auth_admin;
revoke all
  on table public.user_roles
  from authenticated, anon, public;
create policy "Allow auth admin to read user roles" ON public.user_roles
as permissive for select
to supabase_auth_admin
using (true);
grant all
  on table public.role_permissions
  to supabase_auth_admin;

-- Fix the authorize function to work with user_roles array
create or replace function public.authorize(
  requested_permission app_permission
)
returns boolean as $$
declare
  bind_permissions int;
  user_roles_array public.app_role[];
begin
  -- Fetch user roles array from JWT
  select (auth.jwt() ->> 'user_roles')::public.app_role[] into user_roles_array;
  
  -- If no roles, return false
  if user_roles_array is null or array_length(user_roles_array, 1) = 0 then
    return false;
  end if;
  
  -- Check if ANY of the user's roles has the requested permission
  select count(*)
  into bind_permissions
  from public.role_permissions
  where role_permissions.permission = requested_permission
    and role_permissions.role = any(user_roles_array);
    
  return bind_permissions > 0;
end;
$$ language plpgsql stable security definer set search_path = public;